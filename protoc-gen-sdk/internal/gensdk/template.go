package gensdk

import (
	"bytes"
	"strings"
	"text/template"

	"google.golang.org/grpc/grpclog"

	"github.com/go-core-stack/grpc-core/internal/casing"
	"github.com/go-core-stack/grpc-core/internal/descriptor"
)

type param struct {
	*descriptor.File
	OmitPackageDoc bool
}

type templateParams struct {
	P        param
	Services []*descriptor.Service
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	var targetServices []*descriptor.Service

	for _, msg := range p.Messages {
		msgName := casing.Camel(*msg.Name)
		msg.Name = &msgName
	}

	for _, svc := range p.Services {
		svcName := casing.Camel(*svc.Name)
		svc.Name = &svcName

		for _, meth := range svc.Methods {
			if grpclog.V(2) {
				grpclog.Infof("Processing %s.%s", svc.GetName(), meth.GetName())
			}
			methName := casing.Camel(*meth.Name)
			meth.Name = &methName
		}

		if len(svc.Methods) > 0 {
			targetServices = append(targetServices, svc)
		}
	}

	if len(targetServices) == 0 {
		return "", errNoTargetService
	}

	tp := templateParams{
		P:        p,
		Services: targetServices,
	}

	w := bytes.NewBuffer(nil)
	if err := sdkTemplate.Execute(w, tp); err != nil {
		return "", err
	}

	return w.String(), nil
}

// Helper functions for templates
var templateFuncs = template.FuncMap{
	"toLower":           strings.ToLower,
	"toUpper":           strings.ToUpper,
	"hasPrefix":         strings.HasPrefix,
	"trimPrefix":        strings.TrimPrefix,
	"kebabCase":         toKebabCase,
	"snakeCase":         toSnakeCase,
	"hasPathParams":     hasPathParams,
	"isStreamingMethod": isStreamingMethod,
}

func toKebabCase(s string) string {
	// Convert camelCase/PascalCase to kebab-case
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '-')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func toSnakeCase(s string) string {
	// Convert camelCase/PascalCase to snake_case
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func hasPathParams(meth *descriptor.Method) bool {
	for _, b := range meth.Bindings {
		if len(b.PathParams) > 0 {
			return true
		}
	}
	return false
}

func isStreamingMethod(meth *descriptor.Method) bool {
	return meth.GetClientStreaming() || meth.GetServerStreaming()
}

var sdkTemplate = template.Must(template.New("sdk").Funcs(templateFuncs).Parse(`
// Code generated by protoc-gen-sdk. DO NOT EDIT.
// source: {{.P.GetName}}

package {{.P.GoPkg.Name}}

import (
	"context"
	"os"

	"google.golang.org/protobuf/encoding/protojson"
)

{{range $svc := .Services}}
// {{$svc.GetName}}SDK provides SDK wrapper methods for {{$svc.GetName}} service
type {{$svc.GetName}}SDK struct {
	client {{$svc.GetName}}Client
}

// New{{$svc.GetName}}SDK creates a new SDK wrapper for {{$svc.GetName}} service
// The caller is responsible for creating and managing the gRPC client
func New{{$svc.GetName}}SDK(client {{$svc.GetName}}Client) *{{$svc.GetName}}SDK {
	return &{{$svc.GetName}}SDK{
		client: client,
	}
}

{{range $m := $svc.Methods}}
{{if not (isStreamingMethod $m)}}
// {{$m.GetName}} invokes the {{$m.GetName}} RPC method
func (s *{{$svc.GetName}}SDK) {{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GetName}}) (*{{$m.ResponseType.GetName}}, error) {
	return s.client.{{$m.GetName}}(ctx, req)
}

// {{$m.GetName}}FromJSON invokes {{$m.GetName}} with a JSON request
func (s *{{$svc.GetName}}SDK) {{$m.GetName}}FromJSON(ctx context.Context, jsonData []byte) (*{{$m.ResponseType.GetName}}, error) {
	req := &{{$m.RequestType.GetName}}{}
	if err := protojson.Unmarshal(jsonData, req); err != nil {
		return nil, err
	}
	return s.{{$m.GetName}}(ctx, req)
}

// {{$m.GetName}}FromFile invokes {{$m.GetName}} with a JSON file
func (s *{{$svc.GetName}}SDK) {{$m.GetName}}FromFile(ctx context.Context, filePath string) (*{{$m.ResponseType.GetName}}, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	return s.{{$m.GetName}}FromJSON(ctx, data)
}
{{else}}
// {{$m.GetName}} is a streaming method - pass through to underlying client
func (s *{{$svc.GetName}}SDK) {{$m.GetName}}(ctx context.Context, req *{{$m.RequestType.GetName}}) ({{$svc.GetName}}_{{$m.GetName}}Client, error) {
	return s.client.{{$m.GetName}}(ctx, req)
}
{{end}}
{{end}}
{{end}}
`))
